----------------------------------------------------------------------------------
--
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
--use UNISIM.VComponents.all;

--BAUD RATE supportati: 4800, 9600, 19.2K, 57.6K e 115.2K
--bit meno significativo lanciato per primo
--per l'uart usiamo una macchina a stati
--parity bit pari = 1
--sembra finito, mi sa frequency >> di baud_frequency per funzionare


--Reciver:
entity CORE_UART_RX is
    generic(parity: integer range 0 to 1 := 1;     --<INSERIRE VALORE VOLUTO
            N: integer range 7 to 11 := 10; --da 5 a 9 bit dati e 2 bit start/stop e parity bit --<INSERIRE VALORE VOLUTO
            frequency: integer := 27000000;        --<INSERIRE VALORE VOLUTO
            baud_frequency: integer := 9600        --<INSERIRE VALORE VOLUTO
            );
    port(Rx_in, CLK, RESET: in std_logic;
         Flag, parity_flag: out std_logic;
         Reg_out: out std_logic_vector(N-(2+parity)-1 downto 0) --N-(2+parity) � il valore dei bit - start, stop ed il bit di parit� se c'�
         );
end CORE_UART_RX;


architecture CORE_UART_RX_bh of CORE_UART_RX is

type UART_SM is (idle_bit, start_bit, data_bit, parity_stop_bit, restore);
signal current_state: UART_SM := idle_bit;
signal Rx_data: std_logic;
signal buffer_reg: std_logic_vector(N-(2+parity)-1 downto 0) := (others => '0');
signal N_data: integer := N-(2+parity);
signal bit_index: integer range 0 to N-(2+parity) := 0; --non metto N_data -1 perch� in un if mi serve vada di 1 in pi�
signal clk_frequency: integer := frequency;
signal baud_rate: integer := baud_frequency;  
signal clk_per_bit: integer := clk_frequency/baud_rate;
signal clk_count: integer range 0 to (frequency/baud_frequency)-1 := 0;
signal temp: integer range 0 to 1 := parity;
--signal parity_temp: integer := 0; --nel for  sono variabili nel process perchè devono essere aggiornate più volte
--signal a: integer := 0;



begin

Sample: Rx_data <= Rx_in;

--Sampsdle: process(CLK, RESET) --per ridurre stabilit�
--begin
--    if(RESET = '0') then
--            Rx_data_temp <= '0';
--            Rx_data <= '0';
--    else
--        if(rising_edge(CLK)) then
--            Rx_data_temp <= Rx_in;
--            Rx_data <= Rx_data_temp;
--        end if;
--    end if;
--end process;

--BISOGNA ANCORA METTERE APPOSTO LA A!!!!!

SM_block: process(CLK, RESET)
variable a, parity_temp: integer := 0; --variabili che si aggiornano più volte
begin
--QUI CE DA LAVORARE

    if(RESET = '0') then
        current_state <= idle_bit; --IMPORTANTE
        Flag <= '0';
        --parity_flag <= '0'; il bit viene resettato o per meglio dire settato nuovamente poco prima del flag del buffer_reg così si ha tempo per prenderlo
        Reg_out <= (others => '0');
        clk_count <= 0;
        bit_index <= 0;
        buffer_reg <= (others => '0');
        temp <= parity;
        a := 0;
        
    elsif(rising_edge(CLK)) then
        case current_state is
            when idle_bit =>
                Flag <= '0';
                Reg_out <= (others => '0');
                clk_count <= 0;
                parity_flag <= '0';
                
                if(Rx_data = '1') then
                    current_state <= idle_bit;
                else
                    current_state <= start_bit;
                end if;
                
            when start_bit =>
                Flag <= '0';
                Reg_out <= (others => '0');
                
                if(clk_count = ((clk_per_bit-1)/2)) then
                    current_state <= data_bit;
                    clk_count <= 0;
                else
                    current_state <= start_bit;
                    clk_count <= clk_count + 1;
                end if;
                
            when data_bit =>
                Flag <= '0';
                Reg_out <= (others => '0');
                clk_count <= clk_count + 1;
                
                if(clk_count = clk_per_bit-1) then      ------------------------------------------------------
                    if(bit_index < N_data-1) then       --metto il -1 e concludo lultimo bit mettendo anche il nuovo stato insieme, sennò che un stato in più
                        current_state <= data_bit;
                        clk_count <= 0;
                        buffer_reg(bit_index) <= Rx_data;
                        bit_index <= bit_index + 1;
                    else
                        buffer_reg(bit_index) <= Rx_data;  --(Rx_data si può mettere fuori perchè sta sul if e l'else comunque non è sbagliato)aggiungo   questo così oltre ad andare avanti al prossimo colpo faccio anche l'ultimo bit
                        current_state <= parity_stop_bit;
                        clk_count <= 0;
                        bit_index <= 0;
                    end if;
                else
                    current_state <= data_bit;
                    clk_count <= clk_count + 1;
                    
                end if;
                
            when parity_stop_bit => --doppio perche potrebbe non esserci il parity bit
                if(parity = 0) then                           ---------parity = 0 � lo stop
                    if(clk_count = clk_per_bit-1) then
                        current_state <= restore;
                        Flag <= '1';
                        clk_count <= 0;
                        Reg_out <= buffer_reg;
                    else
                        current_state <= parity_stop_bit;
                        Flag <= '0';
                        clk_count <= clk_count + 1;
                        Reg_out <= (others => '0');
                    end if;
                elsif(temp = 1) then                         ---------parity = 1, temp = 1 � il parity state
                    if(clk_count = clk_per_bit-1) then        --ATTENZIONE devo effettivamente inserire il bit di parity che vede se disp o pari
                        temp <= 0;                            --nel ricevitore � un comparatore che se ce paro o disp allora attiva un flag
                        current_state <= parity_stop_bit;
                        clk_count <= 0;
                        Reg_out <= (others => '0');
                        
                        if(Rx_data = '1') then                --i due if con a servono perche a � integer e parity_temp � std_logic_vector
                            a := 1;
                        else
                            a := 0;
                        end if;
                        
                        parity_temp := a;                   --il bit in rx_data ossia il parity entra nel conteggio
                        a := 0;
                        for i in 0 to N-(2+parity)-1 loop
                            if (buffer_reg(i) = '1') then
                                a := 1;
                            else
                                a := 0;
                            end if;
                        parity_temp := parity_temp + a;      --parity non cresce perchè l'aggiornamento è solo alla fine del process
                        end loop;
                        
                        a := 0; --resettiamo a
                        
                        if(parity_temp mod 2 = 1) then --somma dei bit � giusta
                            parity_flag <= '1';
                        else
                            parity_flag <= '0';
                        end if;
                        
                    else
                        Flag <= '0';
                        clk_count <= clk_count + 1;
                        Reg_out <= (others => '0');
                    end if;
                else                                        ----------temp = 0 � lo stop
                    if(clk_count = clk_per_bit-1) then
                        current_state <= restore;
                        Flag <= '1';
                        clk_count <= 0;
                        Reg_out <= buffer_reg;
                    else
                        current_state <= parity_stop_bit;
                        Flag <= '0';
                        clk_count <= clk_count + 1;
                        Reg_out <= (others => '0');
                    end if;
                end if;
                
            when restore =>      --alcuni sono ridondanti, Reg_out rimane del valore inviato, invece il flag deve essere preso in tempo
                current_state <= idle_bit;
                buffer_reg <= (others => '0');
                Flag <= '0';
                clk_count <= 0;
                temp <= parity;
                bit_index <= 0;
                --parity_flag <= '0';
                parity_temp := 0;
            when others =>
                current_state <= idle_bit;
            
        end case;
    end if;
end process;



end CORE_UART_RX_bh;
